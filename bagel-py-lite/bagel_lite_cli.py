#!/usr/bin/env python3

from bagel_lite import BagelReader, BagelWriter

import argparse
from getpass import getpass
import sys
import io

HELP_TEXT = """\
INPUT defaults to standard input, and OUTPUT defaults to standard output.
If OUTPUT exists, it will be overwritten.

RECIPIENT can be an age public key generated by age-keygen ("age1...").

Recipient files contain one or more recipients, one per line. Empty lines
and lines starting with "#" are ignored as comments. "-" may be used to
read recipients from standard input.

Identity files contain one or more secret keys ("AGE-SECRET-KEY-1..."),
one per line. Empty lines and lines starting with "#" are
ignored as comments. Multiple key files can be provided, and any unused ones
will be ignored. "-" may be used to read identities from standard input.

Example:
    $ age-keygen -o key.txt
    Public key: age1ql3z7hjy54pw3hyww5ayyfg7zqgvc7w3j2elw8zmrj2kg5sfn9aqmcac8p
    $ tar cvz ~/data | ./bagel_lite_cli.py -r age1ql3z7hjy54pw3hyww5ayyfg7zqgvc7w3j2elw8zmrj2kg5sfn9aqmcac8p > data.tar.gz.bagel
    $ ./bagel_lite_cli.py --decrypt -i key.txt -o data.tar.gz data.tar.gz.bagel
"""

def parse_recipient_or_identity_file(path):
	results = []
	for line in open(path, "rb").readlines():
		line = line.strip()
		if line and not line.startswith(b"#"):
			results.append(line)
	if not results:
		raise Exception(f"Didn't find any lines in '{path}'")
	return results


def request_passphrase():
	return getpass("Scrypt passphrase: ").encode()


if __name__ == "__main__":
	argparser = argparse.ArgumentParser(
		prog="bagel_lite_cli.py",
		formatter_class=argparse.RawDescriptionHelpFormatter,
		epilog=HELP_TEXT
	)

	encdec = argparser.add_mutually_exclusive_group()
	encdec.add_argument("-e", "--encrypt", action="store_true", default=True, help="Encrypt the input to the output. Default if omitted.")
	encdec.add_argument("-d", "--decrypt", action="store_false", dest="encrypt", help="Decrypt the input to the output.")

	argparser.add_argument("-o", "--output", help="Write the result to the file at path OUTPUT.")
	argparser.add_argument("-p", "--passphrase", action="store_true", help="Encrypt with a passphrase.")
	argparser.add_argument("-r", "--recipient", action="append", default=[], help="Encrypt to the specified RECIPIENT. Can be repeated.")
	argparser.add_argument("-R", "--recipients", action="append", default=[], metavar="PATH", help="Encrypt to recipients listed at PATH. Can be repeated.")
	argparser.add_argument("-i", "--identity", action="append", default=[], metavar="PATH", help="Use the identity file at PATH. Can be repeated.")

	argparser.add_argument("input", metavar="INPUT", nargs="?")


	args = argparser.parse_args()
	#print(args, file=sys.stderr)

	if args.encrypt and not args.passphrase and not (args.recipient + args.recipients + args.identity):
		argparser.print_help()
		argparser.exit()

	if args.input in [None, "-"]:
		input_file = sys.stdin.buffer
	else:
		input_file = open(args.input, "rb")
	
	if args.output in [None, "-"]:
		output_file = sys.stdout.buffer
	else:
		output_file = open(args.output, "wb")
	
	if args.encrypt:
		if args.output != "-" and output_file.isatty():
			raise Exception("refusing to output binary to the terminal (hint: force with '-o -')")
		
		recipients = [r.encode() for r in args.recipient]

		for recip_file in args.recipients:
			if recip_file == "-":
				raise Exception("TODO: support this")
			recipients += parse_recipient_or_identity_file(recip_file)

		if args.identity:
			raise Exception("TODO: support this")

		passphrase = None
		if args.passphrase:
			if recipients:
				argparser.error("Can't use a passphrase in combination with x25519 recipients")
			passphrase = getpass("Scrypt passphrase: ").encode()
	
		if input_file.isatty():
			# work around quirks with detecting EOF from an interactive stdin
			input_file = io.BytesIO(input_file.read())

		bagel = BagelWriter(recipients, passphrase)
		bagel.encrypt(output_file, input_file)
	else: # decrypt
		identities = []
		for ident_file in args.identity:
			if ident_file == "-":
				raise Exception("TODO: support this")
			identities += parse_recipient_or_identity_file(ident_file)
		
		bagel = BagelReader(identities, request_passphrase)
		bagel.decrypt(output_file, input_file)

	input_file.close()
	output_file.close()
